# Kindista

## Overview
Kindista is a social network for local resource sharing built in Common Lisp. It helps people develop trust, opportunities, and mutual generosity within their real-world communities by sharing resources (skills, tools, materials, space), showing gratitude, and connecting with others contributing to a sharing culture.

**Live site**: https://kindista.org

## Critical Current Issues

### 1. System Crashes (PRIORITY 1) - FIX IN TESTING
- **Problem**: Site crashes every couple of weeks
- **Impact**: Production downtime requiring manual restarts
- **Status**: Fix applied 2026-01-03, testing in production

#### Investigation Results (2026-01-03)
**Root Cause Identified**: Unclosed string-output-streams leaking in access logging

**Diagnostic Data** (after 2.3 days uptime):
- 11,908 **open** string-output-streams (should be ~0)
- 7,239 closed streams (garbage collected)
- 630K total string objects consuming 157 MB
- Memory: 397 MB RSS / 2 GB total (plenty of headroom)
- Conclusion: **Stream leak, not memory capacity issue**

**Leak Source**: `acceptor-log-access` in src/http/main.lisp
- Called on EVERY HTTP request to log access
- `format` call had **no error handling** (line 515-529)
- If format fails (malformed headers, bad request data), stream leaks
- Projection: ~12K streams/2.3 days → ~73K streams/14 days → crash

**Why crashes happen**:
- Each open stream maintains internal string buffer
- Streams + buffers accumulate over 2 weeks
- Eventually exhausts memory or triggers GC pathology
- Site ran fine for decade → likely traffic increase or new malformed request patterns

#### Fix Applied (Commit 759b0ad)
**Changes to src/http/main.lisp**:
1. Added `handler-case` around access log format call
2. On error: logs to errors file with diagnostic data
3. Prevents stream leak even when format fails

**New monitoring functions**:
- `count-open-string-streams()` - track leak in real-time
- `get-memory-usage-mb()` - monitor memory consumption
- Access log errors now include: IP address, stream count, memory usage

**Error logging format**:
```
Error writing to access log from IP <ip> (forwarded: <ip>): <error> [Open streams: N, Memory: M MB]
```

#### Testing & Verification
**To confirm fix works**:
- [ ] Stream count stops growing (check daily)
- [ ] Memory usage stabilizes
- [ ] Errors file shows any access log failures with IPs
- [ ] Site stays up 2+ weeks without crash
- [ ] Can identify/block bad actors from error logs

**Monitoring**:
```lisp
;; Check current status in REPL
(count-open-string-streams)  ; Should stay low/stable
(get-memory-usage-mb)        ; Should not grow indefinitely
```

**Alternative hypotheses if this doesn't fix it**:
- Other unclosed streams/resources in different code paths
- SBCL GC bug with long-running processes (version 1.4.16 from 2018)

### 2. No Unit Tests (PRIORITY 2)
- **Problem**: Zero test coverage
- **Impact**: No safety net for refactoring or bug fixes
- **Needed**:
  - Test framework selection (e.g., FiveAM, Prove, Parachute)
  - Critical path coverage first
  - Database operations testing
  - Web handler testing

## Tech Stack

### Language & Runtime
- **SBCL** (Steel Bank Common Lisp) - 100% of codebase
- **Quicklisp** - Package management
- Common Lisp libraries only

### Web Infrastructure
- **Nginx** - Reverse proxy, static file serving
- **Hunchentoot** - Common Lisp web server (listens on port 5000)
- Nginx proxies requests to Hunchentoot for dynamic content

### Email
- **Postfix** - Mail transfer agent
- **Mailgun** - Email service provider for reliable delivery
- Used for user notifications, password resets, sharing alerts, etc.

### Data Storage
- **Custom text-based database** generated by Common Lisp
- No traditional SQL/NoSQL database
- Database location: defined in settings.lisp (+db-path+)
- Avatar storage: defined in settings.lisp (+avatar-path+)

### Version Control
- **Git** - Source control management
- Repository: https://github.com/kindista/kindista

### Static Assets
- `/html/` - Static HTML files
- `/js/` - JavaScript
- `/media/` - Media assets including avatars
- Served directly by Nginx (not through Hunchentoot)

## Project Structure

```
kindista/
├── src/               # Main Common Lisp source code
├── html/              # Static HTML files
├── js/                # JavaScript files
├── media/             # Media files, avatars
├── doc/               # Documentation
├── kindista.asd       # ASDF system definition (main)
├── kindista-js.asd    # ASDF system definition (JavaScript-related)
└── settings.lisp      # Configuration (copy from settings.lisp.example)
```

## Key Files

### System Definitions
- **kindista.asd** - Main ASDF system definition with dependencies
- **kindista-js.asd** - JavaScript-related system definition
- Check these files for the complete list of Quicklisp dependencies

### Configuration
- **settings.lisp.example** - Template for settings
- **settings.lisp** - Local configuration (git-ignored)
  - Contains +db-path+ constant (default: /srv/kindista/)
  - Contains +avatar-path+ constant (default: /srv/kindista/media/avatar/)
  - Email configuration for Postfix/Mailgun integration
  - Must be created by copying .example file and updating paths

### Server Setup
- **server-migration-checklist.md** - Server migration procedures
- Postfix configuration for email sending
- Mailgun credentials for email delivery

## Development Setup

### Prerequisites
1. SBCL installed
2. Quicklisp installed
3. SLIME (for Emacs) or SLIMV (for Vim) recommended
4. Nginx configured (see Nginx section below)

### Initial Setup
```lisp
;; 1. Create settings.lisp from template
;; 2. Update paths in settings.lisp to your local directory

;; 3. Create symlink for Quicklisp
;; ln -s /path/to/kindista ~/quicklisp/local-projects/kindista

;; 4. Load in REPL
(ql:quickload :kindista)
(in-package :kindista)
(run)
```

### Nginx Configuration
Nginx handles:
- Static file serving from `/html/` and `/media/`
- Proxying dynamic requests to Hunchentoot on localhost:5000
- Avatar fallback (404 → /media/avatar/none.png)

See README.md for complete Nginx configuration example.

## Development Workflow

### REPL-Driven Development
This is a Common Lisp project - development happens in the REPL:
1. Load the system with `(ql:quickload :kindista)`
2. Make changes in source files
3. Compile changes with `C-c C-c` (in Emacs/SLIME) or `,c` (in Vim/SLIMV)
4. Test changes immediately in running system
5. No need to restart server for most changes

### Hot Reloading
Most code changes can be compiled and tested without restarting the Hunchentoot server.

## Common Patterns & Conventions

### Package Structure
- Main package: `:kindista`
- Check src/ files for defpackage declarations

### Database Operations
- Custom text-based persistence
- Database state managed in memory
- Periodically serialized to disk
- **Important**: Database format is bespoke - understand before modifying

### Web Handlers
- Hunchentoot handlers defined in src/
- Routes map to handler functions
- Static content bypasses Hunchentoot (served by Nginx)

## SBCL & Garbage Collection

### Current GC Concerns
This is a **slow memory leak** issue - something accumulates over ~2 weeks until crash.

**Common Lisp Leak Patterns to Check:**
1. **Global hash tables** that grow without bounds
   - User sessions never expiring
   - Caches without size limits or eviction
   - Memoization that never clears old entries

2. **Closures capturing large environments**
   ```lisp
   ;; BAD: Closure captures entire large-data-structure
   (lambda () (process (nth 0 large-data-structure)))
   
   ;; GOOD: Extract what you need first
   (let ((item (nth 0 large-data-structure)))
     (lambda () (process item)))
   ```

3. **Circular references in CLOS objects**
   - Parent references child, child references parent
   - No weak references to break cycles

4. **Unclosed streams or connections**
   - File handles left open
   - Database connections not released
   - Network sockets not closed

5. **Thread-local storage accumulation**
   - Each request creates new thread-local data
   - Data never cleaned up when thread ends

6. **Lists built with `append` in loops**
   ```lisp
   ;; BAD: Creates intermediate lists
   (loop for item in items
         append (process item))  ; Memory leak!
   
   ;; GOOD: Use nconc or collect
   (loop for item in items
         nconc (process item))
   ```

### Debugging Approach
When investigating crashes, check:
- `(sb-ext:gc-logfile "/tmp/gc.log")` - Enable GC logging
- `(room)` - Check memory usage in REPL
- `(sb-ext:dynamic-space-size)` - Current dynamic space allocation
- Thread-local allocation issues
- Long-lived objects preventing collection
- Hash table sizes: `(hash-table-count *some-global-table*)`

### GC Tuning (If Needed)
```lisp
;; Force more aggressive GC
(sb-ext:gc :full t)

;; Log GC events
(setf (sb-ext:gc-logfile) "/var/log/sbcl-gc.log")

;; Check generation parameters
(sb-ext:generation-average-age 0)
```

## Testing Strategy (To Be Implemented)

### Recommended Test Framework
Consider FiveAM or Prove for testing infrastructure.

### Priority Test Areas
1. **Database operations** - Serialization/deserialization
2. **Core business logic** - Sharing, gratitude, user management
3. **Web handlers** - Request/response correctness
4. **GC/Memory** - Long-running stability tests
5. **Edge cases** - Malformed data, concurrent access

### Test File Organization
Following Common Lisp conventions:
```
tests/
├── kindista-tests.asd
└── src/
    ├── database-tests.lisp
    ├── web-tests.lisp
    └── integration-tests.lisp
```

## Debugging & Troubleshooting

### Common Issues
- **Port 5000 in use**: Another Hunchentoot instance running
- **Settings.lisp missing**: Copy from settings.lisp.example
- **Database path errors**: Update +db-path+ in settings.lisp
- **Nginx 502 errors**: Hunchentoot not running or misconfigured

### REPL Debugging
```lisp
;; Check if server is running
(hunchentoot:started-p *acceptor*)

;; Restart acceptor
(hunchentoot:stop *acceptor*)
(hunchentoot:start *acceptor*)

;; Inspect current state
(describe *some-important-variable*)
```

## Performance Considerations

### Known Performance Characteristics
- Single-threaded or multi-threaded Hunchentoot?
- Database I/O patterns
- Memory usage patterns over time
- Session storage approach

**TODO**: Document actual threading model and memory usage patterns after investigation.

## Production Deployment

### Hosting Environment
- **Provider**: Linode
- **Instance Size**: 2 GB RAM (upgraded from 1GB)
- **Memory Usage**: Typically ~776MB used (plenty of headroom)
- **Uptime Pattern**: Runs fine for ~2 weeks, then crashes with memory still available
- **Historical Context**: Ran on 1GB instance for a decade without issues
- **Important**: Crashes are NOT due to memory capacity - it's a leak/GC bug

### Current Setup
- Runs on a server with Nginx + SBCL + Hunchentoot + Postfix
- See `server-migration-checklist.md` for deployment procedures
- Crashes require manual restart (no automated recovery yet)
- Upgrade from 1GB to 2GB did NOT solve the crash issue

### Monitoring Needs
- Memory growth over time (track leak accumulation)
- Process uptime monitoring
- GC statistics collection (frequency, duration, effectiveness)
- Automated restart on crash
- Heap size tracking over weeks
- Object allocation patterns
- Session/connection lifecycle tracking

## Code Style & Conventions

### Lisp Conventions
- Hyphenated names: `user-profile`, `show-gratitude`
- Constants with +earmuffs+: `+db-path+`
- Special variables with *earmuffs*: `*acceptor*`
- Predicates end in `p` or `-p`: `user-exists-p`

### When Making Changes
1. Follow existing code style in the module
2. Test in REPL before committing
3. Consider impact on running production system
4. Document non-obvious behavior
5. **Once tests exist**: Ensure tests pass

## Dependencies

See `kindista.asd` for complete list of Quicklisp dependencies.
Load with: `(ql:quickload :kindista)`

## Contributing

Contact: info@kindista.org

## License

AGPL-3.0 (see COPYING file)

## Resources

- **Repository**: https://github.com/kindista/kindista
- **SBCL Documentation**: http://www.sbcl.org/manual/
- **Hunchentoot**: https://edicl.github.io/hunchentoot/
- **Common Lisp Hyperspec**: http://www.lispworks.com/documentation/HyperSpec/
- **Common Lisp Cookbook**: https://lispcookbook.github.io/cl-cookbook/

---

## Notes for Claude Code

### Primary Objectives
1. **Diagnose and fix crash issue** - Focus on GC tuning, memory leaks, thread management
2. **Implement test infrastructure** - Set up testing framework and write critical tests
3. **Improve stability** - Add monitoring, logging, and automated recovery

### Investigation Approach for Crashes
- **KEY INSIGHT**: This is a slow leak, not capacity exhaustion
  - System runs fine for weeks with plenty of free memory
  - Then crashes with ~1.2GB still free
  - Something is accumulating that GC can't/won't collect
  
- **Leak Detection Strategy**:
  - Enable SBCL heap instrumentation: `(sb-ext:gc :full t)` periodically
  - Track object counts over time: `(room t)` logged daily
  - Check for growing collections (hash tables, lists, arrays)
  - Inspect long-lived objects: `(sb-vm:list-allocated-objects :all)`
  - Monitor Hunchentoot session storage (are old sessions cleaned up?)
  - Check for closures capturing large environments
  - Look for circular references (A references B, B references A)
  
- **Hunchentoot-Specific Issues**:
  - Session cleanup configuration - are sessions expiring?
  - Thread pool behavior - threads being created but not destroyed?
  - Request/response objects being retained somewhere?
  - Connection pooling issues?
  
- **Code Review Focus**:
  - What changed before the leak started appearing?
  - Global variables that accumulate data
  - Caches without eviction policies
  - Event handlers or callbacks that retain context
  - Database operations that keep objects in memory

### SBCL Debugging Tools for Leak Detection
```lisp
;; Enable GC logging
(setf (sb-ext:gc-logfile) "/tmp/sbcl-gc.log")

;; Check heap statistics
(room t)

;; Force full GC and see what remains
(sb-ext:gc :full t)
(room t)

;; List allocated objects by type (SBCL 2.0+)
(sb-vm:list-allocated-objects :all)

;; Get detailed memory map
(sb-vm:memory-usage :print-spaces t :count-spaces t)

;; Inspect generation statistics
(sb-ext:generation-average-age 0)
```

### Monitoring Over Time
Set up a cron job to log memory stats daily:
```bash
# Log memory every 6 hours to track growth
echo "(room t)" | sbcl --noinform --eval '(load "quicklisp/setup.lisp")' \
  --eval '(ql:quickload :kindista :silent t)' \
  >> /var/log/kindista-memory.log
```

### Testing Implementation Strategy
- Start with core database operations
- Add handler tests for main user flows
- Build up to integration tests
- Consider property-based testing for data consistency

### Important Constraints
- Production system is live - changes must not cause additional downtime
- No database schema - work within existing text-based format
- SBCL-specific code is acceptable and expected
- REPL workflow is the norm - embrace it
